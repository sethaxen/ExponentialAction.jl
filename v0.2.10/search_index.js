var documenterSearchIndex = {"docs":
[{"location":"lib/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Documentation for ExponentialAction.jl's internal functions.","category":"page"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"See the Public Documentation section for documentation of the public interface.","category":"page"},{"location":"lib/internals/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"lib/internals/#Internal-Interface","page":"Internals","title":"Internal Interface","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [ExponentialAction]\nPublic = false\nPrivate = true","category":"page"},{"location":"lib/internals/#ExponentialAction.expv_taylor-NTuple{4, Any}","page":"Internals","title":"ExponentialAction.expv_taylor","text":"expv_taylor(t, A, B, degree_max; tol)\n\nCompute exp(tA)B using the truncated Taylor series with degree m= degree_max.\n\nInstead of computing the Taylor series T_m(tA) of the matrix exponential directly, its action on B is computed instead.\n\nThe series is truncated early if\n\nfraclVert exp(t A) B - T_m(tA) B rVert_1lVert T_m(tA) B rVert_1 le mathrmtol\n\nwhere lVert X rVert_1 is the operator 1-norm of the matrix X. This condition is only approximately checked.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#ExponentialAction.expv_taylor_cache-NTuple{6, Any}","page":"Internals","title":"ExponentialAction.expv_taylor_cache","text":"expv_taylor_cache(t, A, B, degree_max, k, Z; tol)\n\nCompute exp(tkA)B using the truncated Taylor series with degree m= degree_max.\n\nThis method stores all matrix products in a cache Z, where Z_p = frac1(p-1) (t A)^p-1 B. This cache can be reused if k changes but t, A, and B are unchanged.\n\nZ is a vector of arrays of the same shape as B and is not mutated; instead the (possibly updated) cache is returned.\n\nReturns\n\nF::AbstractMatrix: The action of the truncated Taylor series\nZ::AbstractVector: The cache of matrix products of the same shape as F. If the cache is updated, then this is a different object than the input Z.\n\nSee expv_taylor.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#ExponentialAction.parameters-Tuple{Any, Any, Any}","page":"Internals","title":"ExponentialAction.parameters","text":"parameters(t, A, ncols_B; kwargs...) -> (degree_opt, scale)\n\nCompute Taylor series parameters needed for exp(tA)B.\n\nThis is Code Fragment 3.1 from [AlMohyHigham2011].\n\n[AlMohyHigham2011]: Al-Mohy, Awad H. and Higham, Nicholas J. (2011) Computing the Action of the Matrix Exponential, with an Application to Exponential Integrators. SIAM Journal on Scientific Computing, 33 (2). pp. 488-511. ISSN 1064-8275 doi: 10.1137/100788860 eprint: eprints.maths.manchester.ac.uk/id/eprint/1591\n\nKeywords\n\ntol: the desired relative tolerance\ndegree_max=55: the maximum degree of the truncated Taylor series that will be used. This is m_mathrmmax in [AlMohyHigham2011], where they recommend a value of 55 in §3.\nℓ=2: the number of columns in the matrix that is multiplied for norm estimation (note: currently only used for control flow.). Recommended values are 1 or 2.\n\nReturns\n\ndegree_opt: the degree of the truncated Taylor series that will be used. This is m^* in [AlMohyHigham2011],\nscale: the amount of scaling s that will be applied to A. The truncated Taylor series of exp(t A  s) will be applied s times to B.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Documentation for ExponentialAction.jl's public interface.","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"See the Internals section for documentation of internal functions.","category":"page"},{"location":"lib/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Modules = [ExponentialAction]\nPublic = true\nPrivate = false","category":"page"},{"location":"lib/public/#ExponentialAction.ExponentialAction","page":"Public","title":"ExponentialAction.ExponentialAction","text":"ExponentialAction.jl implements the action of the Matrix exponential.\n\nFor details, see the docstring of expv.\n\nExports\n\nexpv: compute the action of the matrix exponential\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#ExponentialAction.expv-Tuple{Any, Any, Any}","page":"Public","title":"ExponentialAction.expv","text":"expv(t, A, B; shift=true, tol)\n\nCompute exp(tA)B without computing tA or the matrix exponential  exp(tA).\n\nComputing the action of the matrix exponential is significantly faster than computing the matrix exponential and then multiplying it when the second dimension of B is much smaller than the first one. The \"time\" t may be real or complex.\n\nIn short, the approach computes\n\nF = T_m(tA  s)^s B\n\nwhere T_m(X) is the Taylor series of exp(X) truncated to degree m = m^*. The term s determines how many times the Taylor series acts on B. m^* and s are chosen to minimize the number of matrix products needed while maintaining the required tolerance tol.\n\nThe algorithm is described in detail in Algorithm 3.2 in [AlMohyHigham2011].\n\n[AlMohyHigham2011]: Al-Mohy, Awad H. and Higham, Nicholas J. (2011) Computing the Action of the Matrix Exponential, with an Application to Exponential Integrators. SIAM Journal on Scientific Computing, 33 (2). pp. 488-511. ISSN 1064-8275 doi: 10.1137/100788860 eprint: eprints.maths.manchester.ac.uk/id/eprint/1591\n\nKeywords\n\nshift=true: Expand the Taylor series about the n times n matrix A-μI=0 instead of A=0, where μ = operatornametr(A)  n to speed up convergence. See §3.1 of [AlMohyHigham2011].\ntol: The relative tolerance at which to compute the result. Defaults to the tolerance of the eltype of the result.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#ExponentialAction.expv_sequence-Tuple{Any, Any, Any}","page":"Public","title":"ExponentialAction.expv_sequence","text":"expv_sequence(t::AbstractVector, A, B; kwargs...)\n\nCompute exp(t_i A)B for the (sorted) sequence of (real) time points t=(t_1 t_2 ldots).\n\nAt each time point, the result F_i is computed as\n\nF_i = expleft((t_i - t_i-1) Aright) F_i - 1\n\nusing expv, where t_0 = 0 and F_0 = B. For details, see Equation 5.2 of [AlMohyHigham2011].\n\nBecause the cost of computing expv is related to the operator 1-norm of t_i A, this incremental computation is more efficient than computing expv separately for each time point.\n\nSee expv for a description of acceptable kwargs.\n\nexpv_sequence(t::AbstractRange, A, B; kwargs...)\n\nCompute expv over the uniformly spaced sequence.\n\nThis algorithm takes special care to avoid overscaling and to save and reuse matrix products and is described in Algorithm 5.2 of [AlMohyHigham2011].\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ExponentialAction","category":"page"},{"location":"#ExponentialAction","page":"Home","title":"ExponentialAction","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExponentialAction.jl is a lightweight package that implements the action of the Matrix exponential using the algorithm of Al-Mohy and Higham [AlMohyHigham2011][Expmv]. For details, see the docstring of expv.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[AlMohyHigham2011]: Al-Mohy, Awad H. and Higham, Nicholas J. (2011) Computing the Action of the Matrix Exponential, with an Application to Exponential Integrators. SIAM Journal on Scientific Computing, 33 (2). pp. 488-511. ISSN 1064-8275 doi: 10.1137/100788860, eprint: eprints.maths.manchester.ac.uk/id/eprint/1591","category":"page"},{"location":"","page":"Home","title":"Home","text":"[Expmv]: https://github.com/higham/expmv","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is the same algorithm used by SciPy's expm_multiply.","category":"page"},{"location":"","page":"Home","title":"Home","text":"While exp(X) is only defined in LinearAlgebra for Diagonal, Symmetric{<:Real}/Hermitian, and StridedMatrix, expv can take an arbitrary matrix type.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using LinearAlgebra, ExponentialAction\nA = [1.0 2.0; -2.0 3.0];\nB = [1.0, 2.0];\nexp(A) * B\nexpv(1, A, B)\nexp(2A) * B\nexpv(2, A, B)","category":"page"},{"location":"#Automatic-Differentiation-(AD)","page":"Home","title":"Automatic Differentiation (AD)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Special care has been taken to ensure that expv can be differentiated using ForwardDiff.jl, ReverseDiff.jl, ChainRules.jl-compatible packages (e.g. Zygote.jl), and likely others as a result.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This has been achieved by avoiding type constraints, not mutating any arrays, and marking operations only used for control flow as being non-differentiable.","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExponentialUtilities.jl and Expokit.jl both implement an approximation to the action of the matrix exponential using Krylov subspaces. Which package is most efficient or useful depends on the choice of matrix and whether derivatives are needed. If efficiency is important, we recommend choosing from the packages by benchmarking against several of your matrices (if applicable).","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThe packages use different default tolerances. ExponentialAction.jl is more strict. For a fair comparison, select similar tolerances.","category":"page"}]
}
